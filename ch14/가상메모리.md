```
목차
연속메모리 할당 
	- 스와핑
	- 메모리 할당 
	- 외부 단편화 
페이징을 통한 가상 메모리 관리
	- 페이징이란
	- 페이지 테이블
	- 페이징에서의 주소 변환 
페이지 교체와 프레임 할당 
	- 요구 페이징 
	- 페이지 교체 알고리즘 
	- 스래싱과 프레임 할당 

```
## 연속메모리 할당 

프로세스가 메모리에 배치될떄 각 크기만큼 연속적으로 배치되는 것을 `연속 메모리 할당` 이라고 한다.
연속메모리 할당시 고려해야하는 점과 잠재적인 문제가 있다.

### 스와핑 
---
![[../image/chapter14/가상메모리-1.jpeg]]

메모리상에서 사용하지 않는 프로세스는 보조기억장치의 `스왑 영역`으로 보내진다.
메모리에서 스왑영역으로 옮겨지는 것을 `스왑 아웃` 스왑영역에서 메모리로 옮겨지는 것을 `스왑 인 `이라고 함 
실행할 프로세스의 총량이 메모리보다 큰 경우도 스와핑 방법을 사용하면 실행할 수 있다. 

### 메모리 할당 
---
프로세스는 메모리 내의 빈공간에 적재되어야 한다. 
대표적인 세가지 방식을 통해 프로세스를 연속적으로 할당할 수 있다. 

#### 최적 적합 
운영체제가 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 배치하는 방식
즉시 메모리를 할당하는 방식으로 빠른 할당이 가능하다.

#### 최소 적합 
운영체제가 빈 공간을 모두 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

#### 최악 적합
빈 공간을 모두 검색해 본 후 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 외부 단편화 
---
![[../image/chapter14/가상메모리-2.jpeg]]
프로세스를 연속적으로 배치하는 것은 `외부 단편화` 문제를 내포하고 있다. 
차례대로 프로세스를 적재했을때 프로세스가 끝나는 순서는 효율적으로 끝나지 않는다. 
메모리 상에서 빈공간이 생겼지만 단편적으로 생기어 총 빈공간을 모두 효율적으로 쓰지 못하는 현상이다. 

![[../image/chapter14/가상메모리-3.jpeg]]

외부 단편화를 해결할 수 있는 대표적인 방식은 메모리를 `압축`하는 방법이 있다. 
메모리의 작은 빈공간을 모아서 큰 공간을 만드는 방법이다. 
빈 공간을 모으는 동안 시스템은 하던 일을 중지해야 하고 메모리를 옮기는 과정 중 오버헤드를 야기한다. 


## 페이징을 통한 가상 메모리 관리 

연속적으로 메모리를 할당하는 방식은 물리 메모리보다 큰 프로세스를 실행할 수 없다.
`가상 메모리`를 통해 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 더 큰 프로세스를 실행하게 한다.
가상 메모리 기법은 `페이징`과 `세그멘테이션` 이 있고 대부분의 운영체제들이 페이징 기법을 사용한다. 

### 페이징이란 
---
![[../image/chapter14/가상메모리-4.jpeg]]

프로세스를 논리적인 단위로 나눈 것을 `페이지` 메모리를 물리적인 단위로 나눈 것을 `프레임`이라고한다. 
페이지 단위로 스왑 인 /아웃 되는 것을 `페이지 인` , `페이지 아웃` 이라고 한다. 
이와 같은 방식을 통해 메모리 영역보다 더 큰 프로세스를 실행시킬 수 있다. 

### 페이지 테이블 
---
![[../image/chapter14/가상메모리-5.jpeg]]
메모리에 불연속적으로 프로세스가 배치되어 있으면 CPU 입장에서 다음에 실행할 명령어 위치를 찾기 어렵다.
프로세스가 물리적인 주소(메모리) 내에서 불연속적지만 논리적 주소는 연속적으로 배치되는 페이지 테이블을 이용한다.

#### PTBR 
프로세스는 각자마다 프로세스 테이블을 가지고 있으며 `페이지 테이블 베이스 레지스터 (PTBR) ` 라고한다. 
CPU는 PTBR을 문맥교환시마다 확인하여 적제된 프레임 위치를 확인한다. 

#### TLB
![[../image/chapter14/가상메모리-6.jpeg]]

페이지 테이블은 보통 메모리 상에 함께 존재하는데 CPU 입장에서는 메모리에 두번 접근하는 셈이다.
CPU 곁에 `TLB`라는 페이지 테이블의 캐시 메모리를 두어 CPU가 사용하게 한다.
접근하고자 하는 페이지 번호가 TLB상에 있을경우 `TLB 히트` TLB 상에 없을경우 `TLB 미스` 라고한다.

### 페이징에서의 주소 변환 
---
![[../image/chapter14/가상메모리-7.png]]

하나의 페이지 혹은 프레임을 여러주소를 포괄하고 있다.
특정 주소에 접근하기 위해서는 두가지 정보가 필요하다. 
1. 어떤 페이지 혹은 프레임에 접근하고 싶은지 
2. 접근하려는 주소가 그 페이지 혹은 프레임에서 얼마나 떨어져 있는지 
위 사항을 바탕으로 페이징 시스템에서는 모든 논리 주소가 `페이징 번호` 와 `변위`로  이루어져있다. 

![[../image/chapter14/가상메모리-8.jpeg]]

CPU가 특정 주소로 접근하는 방식은 페이지 번호를 확인하고 페이지 테이블에서 매칭되는 프레임을 찾은 뒤 
프레임 내에서 떨어진 변위만큼 찾는 방식이다. 

### 페이지 테이블 엔트리 
---
페이지 테이블은 중요한 다른 정보들을 더 담고 있다 각 엔트리 별로 있다고 하여 `페이지 테이블 엔트리` 라고한다.
대표적인 엔트리로 유효비트 , 보호 비트 , 참조 비트 ,수정 비트가 있다. 

#### 유효 비트 
페이징에서도 스와핑이 가능하며 일부 페이지는 스왑영역에 존재하는데 메모리에 적재되어 있는지를 판단해준다.
유효비트가 1이면 메모리에 적재되어 있고 0인경우는 스왑영역에 존재한다.
유효 비트가 0인 페이지로 접근하려고 하면 예외인 `페이지 폴트` 가 발생한다 .
CPU 가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트와 유사하다. 
- 기존작업 백업 > 페이지 폴트 루틴 실행 > 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경 

#### 보호 비트 
페이지 보호 기능을 위해 존재하는 비트이며  해당 페이지가 읽거나 쓰기가 가능한 페이지인지 확인한다. 
보호비트는 세 개의 비트로 조금 더 복잡하게 구현될 수 있다. 
Read : r , Write : w , eXecute : x 로 표현된다. 

#### 참조 비트 
cpu가 해당 페이지를 읽거나  쓴 경우 1로 세팅 된다. 한번도 쓴적이 없으면 0 으로 세팅된다.

#### 수정 비트 
해당 페이지에 데이터를 쓴적이 있는지 없는지 수정 여부를 알려준다. 
변경 된 적이 있으면 1 없으면 0 이다.
수정비트의 존재이유는 스왑영역으로 스왑인과 아웃될떄 같은 작업을 방지하기 위함이다.

 

## 페이지 교체와 프레임 할당 
운영체제가 어떻게 적절한 수의 프레임을 할당하여 페이지를 할당하는지 알수 있다.
운영체제가 불필요한 페이지를 보조기억장치로 보[ㅔ내어 어떻게 한정된 메모리를 사용하는지 알 수 있다. 

### 요구 페이징 
---
프로세스에 모든 페이지를 적재하지 않고 필요한 페이지만 적재하는 것을 `요구 페이징` 기법이라고 한다. 
아무런 페이지를 적재하지 않고 페이지 폴트를 발생시켜 필요 페이지를 적재하는 것을 `순수 요구 페이징`이라고 한다.
요구 페이징 기법을 안정적으로 작동하려면 `페이지 교체`와 `프레임 할당` 을 해결해야 한다. 
어느 페이지를 내보내는 것이 최선이지 결정하는 방법을 `페이지 교체 알고리즘`이라고 한다.
### 페이지 교체 알고리즘 
---
좋은 페이지 교체 알고리즘은 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다. 
보조기억장치에서 페이지를 가져오는 것이 메모리에서 가져오는 것보다 느리기 떄문이다. 
페이지 교체 알고리즘의 성능은 페이지 참조열의 개수로 파악해야 한다. 
페이지 접근 2 2 2 3 5 5 5 3 3 7  > 2 3 5 3 7 를 참조열로 볼수 있다. 
#### FIFO 페이지 교체 알고리즘 

![[../image/chapter14/가상메모리-9.jpeg]]
가장 먼저 올라온 페이지 부터 내쫓는 방식이다. 
FIFO 페이지 교체 알고리즘은 아이디어와 구현이 간단하지만 프로그램 실행 내내 사용될 내용이 포함될 수 있다. 
- 보완책 = 2차 기회(second-chance) 페이지 교체 알고리즘
    - 참조 비트 1: CPU가 한 번 참조한 적이 있는 페이지
        - 참조 비트 0으로 초기화 후 적재 시간을 현재 시간으로 설정 (한 번 더 기회를 줌)
    - 참조 비트 0: CPU가 참조한 적이 없는 페이지
        - 내쫓음
#### 최적 페이지 교체 알고리즘

![](https://velog.velcdn.com/images/mmodestaa/post/26828656-d52b-4930-a527-9c9706421672/image.png)

- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    - 페이지 참조열을 참고해 이후에 가장 사용되지 않을 페이지를 내쫓음
- 가장 낮은 페이지 폴트율을 보장하는 페이지 교체 알고리즘
    - BUT 실제 구현이 어려움
    - 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주

#### LRU (Least-Recently-Used) 페이지 교체 알고리즘

![](https://velog.velcdn.com/images/mmodestaa/post/7aec330d-9886-4ddd-90fd-9ba4f987c70f/image.png)

- 최적 페이지 교체 알고리즘 = 가장 오래 사용되지 않을 페이지 교체
- LRU 페이지 교체 알고리즘 = 가장 오래 사용되지 않은 페이지 교체
    - 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 가정

### 스래싱과 프레임 할당 
---
#### 스래싱

- 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제  
    ![](https://velog.velcdn.com/images/mmodestaa/post/1a3df088-baaf-4f8a-9615-a88294f99f48/image.png)
    - 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것은 아님
    - 멀티프로그래밍의 정도 = 메모리에 동시에 실행되는 프로세스의 수
- 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
- 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야

#### 균등 할당 (equal allocation)

- 가장 단순한 할당 방식
- 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
- 정적 할당 방식
    - 프로세스의 실행 과정 고려 X, 프로세스 혹은 물리 메모리 크기만 고려

#### 비례 할당 (proportional allocation)

- 프로세스의 크기를 고려
- 프로세스 크기에 비례하여 프레임 할당
- 정적 할당 방식
- BUT 프로세스가 필요로 하는 프레임 수는 실행해봐야 알 수 있음
    - 크기가 큰 프로세스인데 실행하니 많은 프레임을 필요로 하지 않거나
    - 크기가 작은 프로세스인데 실행하니 많은 프레임을 필요로 하거나

#### 작업 집합 모델

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 스래싱이 발생하는 이유는 빈번한 페이지 교체 때문
    - CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당
- 프로세스가 일정 기간동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
    - 작업 집합이란 실행 중인 프로세스가 일정 시간동안 참조한 페이지의 집합
- 작업 집합을 구하려면 1. 프로세스가 참조한 페이지 2. 시간 간격이 필요
- 동적 할당 방식

#### 페이지 폴트 빈도

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 두 개의 가정에서 생겨난 아이디어  
    ![](https://velog.velcdn.com/images/mmodestaa/post/215dd1c2-7fce-460f-bc51-a52aa60af199/image.png)
    - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있음
    - 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있음
- 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당
- 동적 할당 방식