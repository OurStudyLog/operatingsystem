생성일 | 2024.01.28
작성자 | 이지현
# 14-2 페이징을 통한 가상 메모리 관리

### 요약
- 페이징은 물리 주소 공간을 프레임 단위로 자르고 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 페이지 테이블을 통해 페이지가 적재된 프레임을 찾을 수 있다. 페이지 테이블에는 페이지 번호와 프레임 번호뿐 아니라 유효 비트, 보호 비트, 접근 비트, 수정 비트 등이 있다.
- PTBR은 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
- TLB는 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장한다.

가상 메모리: 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

---
## 페이징이란

- 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법.
- 페이지 아웃: 페이징 시스템에서의 스왑 아웃
- 페이지 인: 스왑 인

> 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다. 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다. 즉, 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.


---

## 페이지 테이블

- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 없다.
- 페이지 테이블: 페이징 시스템에서 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록하는 것.
	- 페이지 테이블 베이스 레지스터(PTBR: Page Table Base Register): 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

> [!내부 단편화]
> 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자르는데, 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다. 애매하게 남은 크기로 인해 메모리 낭비가 되는데, 이를 내부 단편화라고 한다. 이를 방지하기 위해 페이지 단위를 너무 작게 쪼개도 페이지 테이블이 차지하는 공간만큼 낭비가 된다. 페이지 단위를 기본과 더불어 더 큰 단위도 일부 허용하는 방식으로 해결하고 있다.

- 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다.
- TLB:  CPU 곁에 페이지 테이블의 캐시 메모리를 둔다. 캐시이기에 일부 내용만을 저장하며, 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져온다.
- TLB 히트: CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
- TLB 미스: 페이지 번호가 TLB에 없을 경우

---

## 페이징에서의 주소 변환

- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

- 모든 논리 주소가 기본적으로 페이지 번호와 변위로 이루어져 있다.
- 즉, 논리 주소<페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.

---

## 페이지 테이블 엔트리

- 페이지 테이블 엔트리: 페이지 테이블의 각각의 행들
- 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 등의 정보들이 있다.

### 유효 비트

- 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
- 현재 페이지가 메모리에 적재되어 있다면 1, 적재되어 있지 않다면 0.
- 페이지 폴트(예외) : 유효 비특 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 할 때 발생하는 예외.
	- 페이지 폴트 처리 과정
	1. CPU는 기존의 작업 내역을 백업한다.
	2. 페이지 폴트 처리 루틴을 실행한다.
	3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를1로 변경해 준다.
	4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 된다.

### 보호비트

- 페이지 보호 기능을 위해 존재하는 비트.
- 읽고 쓰기 가능 여부인지를 확인한다. 읽기만 가능한 페이지는 0, 쓰기까지 가능한 페이지는 1.
- 코드 영역은 읽기 전용 영역으로 보호 비트는 0.
- r, w, x(읽기, 쓰기, 실행)하기의 조합으로 표현가능하다.
	- 110 = 읽고 쓰기는 가능하나 실행은 불가능하다.

### 참조 비트

- CPU가 이 페이지에 접근한 적이 있는지 여부.
- 적재 이후 CPU가 접근한 적이 있다면 1, 없다면 0.

### 수정 비트

- 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
- 더티 비트라고도 부른다.
- 1이면 변경된 적이 있는지, 0이면 변경된 적이 없는 페이지.
- 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.

> [!쓰기 시 복사]
> 프로세스 간에 페이지를 공유할 수 있다는 페이징의 이점이 있다. 대표적인 예시인 쓰기 시 복사. 부모 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다. 굳이 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있게 하는 것이다. 그러나, 쓰기가 이뤄지면 그때 페이지가 별도의 공간으로 복제된다. 프로세스 생성 시간을 줄이며, 메모리 공간 절약도 가능하다.

---

## 계층적 페이징

- 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법으로 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식. ( = 다단계 페이지 테이블)

----
### 퀴즈

디스커션 링크: