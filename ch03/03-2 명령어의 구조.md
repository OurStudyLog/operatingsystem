생성일 | 2023.12.30
작성자 | 이지현
# 03-2 명령어의 구조

### 요약
- 명령어의 구조와 주소 지정 방식
- 명령어의 생김새와 작동 원리

---
## 연산 코드와 오퍼랜드

명령어: 연산 코드와 오퍼랜드로 구성
연산 코드: 명령어가 수행할 연산 -> 연산자
오퍼랜드: 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치 -> 피연산자

![[명령어의구조.png]]
필드: 각각의 영역
오퍼랜드는 여러 개의 필드를 가질 수 있다.

### 연산 코드

1. 데이터 전송
	- MOVE: 데이터를 옮겨라
	- STORE: 메모리에 저장하라
	- LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
	- PUSH: 스택에 데이터를 저장하라
	- POP: 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
	- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셉 / 나눗셈을 수행하라
	- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
	- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
	- COMPARE :  두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
3. 제어 흐름 변경
	- JUMP : 특정 주소로 실행 순서를 옮겨라
	- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
	- HALT : 프로그램의 실행을 멈춰라
	- CALL : 되돌아올 주소를 지정한 채 특정 주소로 실행 순서를 옮겨라
	- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
4. 입출력 제어
	- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
	- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
	- START IO : 입출렬 장치를 시작하라
	- TEST IO : 입출력 장치의 상태를 확인하라

---

## 주소 지정 방식

명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다. 그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.

왜 연산 코드, 연산 코드에 사용될 데이터 형식으로 명령어를 구성하지 않는가?
-> 하나의 명령어가 n 비트로 구성되어 있고, 그중 연산 코드 필드가 m 비트라고 가정해본다면 오퍼랜드의 길이는 n-m 비트, 다음 오퍼랜드 필드의 길이는 n-m-k 등으로 데이터의 크기에 따라 점점 작아질 것이고 매우 가변적이다. 따라서 고정적인 크기를 가진 메모리 주소를 담는 것이다.

유효 주소: 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치
주소 지정 방식: 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법

### 즉시 주소 지정 방식

**연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시하는 방식으로, 가장 간단한 형태의 주소 지정 방식

표현할 수 있는 데이터의 크기가 작아지지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 방식보다 빠르다.

### 직접 주소 지정 방식

오퍼랜드 필드에 **유효 주소**를 직접적으로 명시하는 방식

오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어든다. 즉, 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### 간접 주소 지정 방식

**유효 주소의 주소**를 오퍼랜드 필드에 명시. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌지만, 두 번의 메모리 접근이 필요하기 때문에 상대적으로 느리다.

### 레지스터 주소 지정 방식

직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 지정한 **레지스터**를 오퍼랜드 필드에 직접 명시하는 방법

일반적으로 CPU 외부에 있는 메모리보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르기 때문에 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 다만, 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

### 레지스터 간접 주소 지정 방식

연산에 사용할 데이터를 메모리에 저장하고, 그 **유효 주소를 저정한 레지스터**를 오퍼랜드 필드에 명시하는 방식

유효 주소를 찾는 과정이 간접 주소 방식과 비슷하지만, 메모리 접근 횟수가 한 번으로 줄어들며, 메모리보다 빠르게 접근할 수 있는 레지스터를 사용하여 간접 주소 지정 방식보다 빠르다.

----
### 퀴즈

디스커션 링크: